/**
 * Includes.
 */
#include <pthread.h>
#include <cstdio>
#include <ctime>
#include <cstring>
#include <cstdlib>
#include <climits>
#include <errno.h>
#include <cstring>

/**
 * Defines.
 */
#define T ((LL)RAND_MAX)*(RAND_MAX) // The size of the bounding square.
#define LL long long // Long long alias.
#define M 2500000 // Number of iterations.
#define N 4 // Number of threads, N*M should equal to the M on the serial version.

pthread_t threads[N]; // PThreads objects.
LL area[N]; // Areas counter, number of points inside the area, we use this to avoid mutexes (more overhead).

/**
 * Thread function.
 */
void* function(void* ptr)
{
	LL a, b, cntr;
	int i;
	memcpy(&i, &ptr, sizeof(i)); // Getting the index of the area array we need to use.
	
	// Monte Carlo loop.
	for (cntr = 0; cntr < M; ++cntr)
	{
		a = rand();
		b = rand();
		if (a*a - T <= -b*b) ++area[i]; // Checking if the point is inside the circle.
	}
	
	return NULL;
}

/**
 * Main.
 */
int main()
{
	srand(time(NULL)); // Generate seed.
	printf("RAND MAX IS: %d\n", RAND_MAX); // Check the random max value, probably 2^32 -1.
	
	// Creating threads.
	for (int i = 0; i < N; ++i)
	{
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setstacksize(&attr, 1000); // Setting max stack of the thread to 1KB.
		if (pthread_create(&threads[i], &attr, function, (void*)i) == -1)
			printf("%s\n", strerror(errno)); // Check for errors.
	}
	
	LL res = 0; // Sum of the areas calculated by each thread.
	for (int i = 0; i < N; ++i)
	{
		pthread_join(threads[i], NULL); // Wait for the i thread end.
		res += area[i]; // Add to res the value generated by the i thread.
	}
	
	printf("%lld\n", res*4); // The way this is calculated is explained on the docs.
	
	return 0;
}

